From 8a1dc023446ee4c114646b7cb5f9d6265d29877a Mon Sep 17 00:00:00 2001
From: Dmitry Kazakov <dimula73@gmail.com>
Date: Mon, 15 Apr 2019 13:48:16 +0300
Subject: [PATCH] Fetch tablet mapping from Wintab instead virtual screen
 geometry

Some devices, like Microsoft Surface Pro 5, don't map tablet's
input range to the entire virtual screen area, but map it to
the primary display that has actual built-in tablet sensor.

In such cases we should fetch actualy mapped aread from Wintab's
lcSys{Org,Ext}{X,Y} fields and use it for cursor mapping.

The patch also introduces an environment variable switch that
falls back to the old method of mapping:

QT_IGNORE_WINTAB_MAPPING=1

When the variable is set, the scaling is done via virtual desktop
area only.
---
 .../windows/qwindowstabletsupport.cpp         | 55 ++++++++++++++++++-
 .../platforms/windows/qwindowstabletsupport.h | 11 +++-
 2 files changed, 64 insertions(+), 2 deletions(-)

diff --git a/src/plugins/platforms/windows/qwindowstabletsupport.cpp b/src/plugins/platforms/windows/qwindowstabletsupport.cpp
index 43c6130f..e5aab523 100644
--- a/src/plugins/platforms/windows/qwindowstabletsupport.cpp
+++ b/src/plugins/platforms/windows/qwindowstabletsupport.cpp
@@ -217,6 +217,10 @@ QWindowsTabletSupport::QWindowsTabletSupport(HWND window, HCTX context)
     // Some tablets don't support tilt, check if it is possible,
     if (QWindowsTabletSupport::m_winTab32DLL.wTInfo(WTI_DEVICES, DVC_ORIENTATION, &orientation))
         m_tiltSupport = orientation[0].axResolution && orientation[1].axResolution;
+
+    connect(qGuiApp, &QGuiApplication::primaryScreenChanged,
+            this, QWindowsTabletSupport::slotPrimaryScreenChanged);
+    slotScreenGeometryChanged();
 }
 
 QWindowsTabletSupport::~QWindowsTabletSupport()
@@ -395,6 +399,43 @@ QWindowsTabletDeviceData QWindowsTabletSupport::tabletInit(qint64 uniqueId, UINT
     return result;
 }
 
+void QWindowsTabletSupport::slotPrimaryScreenChanged(QScreen *screen)
+{
+    if (m_connectedScreen)
+        disconnect(m_connectedScreen, 0, this, 0);
+
+    m_connectedScreen = screen;
+
+    if (m_connectedScreen)
+        connect(m_connectedScreen, &QScreen::virtualGeometryChanged,
+                this, &QWindowsTabletSupport::slotScreenGeometryChanged);
+
+    slotScreenGeometryChanged();
+}
+
+void QWindowsTabletSupport::slotScreenGeometryChanged()
+{
+    /**
+     * Some Wintab implementations map the tablet area to the entire
+     * virtual screen, but others (e.g. Microsoft SP5) don't. They
+     * may input range to a single (built-in) screen. The logic is
+     * quite obvious: when the screen has integrated tablet device,
+     * one cannot map this tablet device to another display.
+     *
+     * For such devices, we should always request mapped area from
+     * lcSys{Org,Ext}{X,Y} fields and use it accordingly.
+     */
+
+    LOGCONTEXT lc;
+    QWindowsTabletSupport::m_winTab32DLL.wTInfo(WTI_DEFSYSCTX, 0, &lc);
+    m_mappedScreenGeometry = QRect(lc.lcSysOrgX, lc.lcSysOrgY, lc.lcSysExtX, lc.lcSysExtY);
+
+    qCDebug(lcQpaTablet) << "Updated tablet mapping: " << m_mappedScreenGeometry;
+    if (QGuiApplication::primaryScreen()) {
+        qCDebug(lcQpaTablet) << "   real desktop geometry: " << QWindowsScreen::virtualGeometry(QGuiApplication::primaryScreen()->handle());
+    }
+}
+
 bool QWindowsTabletSupport::translateTabletProximityEvent(WPARAM /* wParam */, LPARAM lParam)
 {
     PACKET proximityBuffer[1]; // we are only interested in the first packet in this case
@@ -538,6 +579,7 @@ bool QWindowsTabletSupport::translateTabletPacketEvent()
 
     static bool customGeometryIsInitialized = false;
     static QRect customGeometry;
+    static bool dontUseWintabDesktopRect = false;
 
     if (!customGeometryIsInitialized) {
         const QString geometry = qEnvironmentVariable("QT_WINTAB_DESKTOP_RECT");
@@ -559,12 +601,23 @@ bool QWindowsTabletSupport::translateTabletPacketEvent()
             }
         }
 
+        if (qEnvironmentVariableIsSet("QT_IGNORE_WINTAB_MAPPING")) {
+            if (!customGeometry.isValid()) {
+                qInfo() << "INFO: fallback mapping is requested via QT_IGNORE_WINTAB_MAPPING";
+            } else {
+                qInfo() << "INFO: ignoring QT_IGNORE_WINTAB_MAPPING, because QT_WINTAB_DESKTOP_RECT is set";
+            }
+            dontUseWintabDesktopRect = true;
+        }
+
         customGeometryIsInitialized = true;
     }
 
     const QRect virtualDesktopArea =
         !customGeometry.isValid() ?
-        QWindowsScreen::virtualGeometry(QGuiApplication::primaryScreen()->handle()) :
+        (dontUseWintabDesktopRect ?
+             QWindowsScreen::virtualGeometry(QGuiApplication::primaryScreen()->handle()) :
+             m_mappedScreenGeometry) :
         customGeometry;
 
     if (QWindowsContext::verbose > 1)  {
diff --git a/src/plugins/platforms/windows/qwindowstabletsupport.h b/src/plugins/platforms/windows/qwindowstabletsupport.h
index 5b1ddb52..e570f56d 100644
--- a/src/plugins/platforms/windows/qwindowstabletsupport.h
+++ b/src/plugins/platforms/windows/qwindowstabletsupport.h
@@ -45,7 +45,9 @@
 
 #include <QtCore/qvector.h>
 #include <QtCore/qpoint.h>
+#include <QtCore/qrect.h>
 #include <QtCore/qmap.h>
+#include <QtCore/qobject.h>
 
 #include <wintab.h>
 
@@ -56,6 +58,7 @@ QT_BEGIN_NAMESPACE
 class QDebug;
 class QWindow;
 class QRect;
+class QScreen;
 
 struct QWindowsWinTab32DLL
 {
@@ -108,7 +111,7 @@ struct QWindowsTabletDeviceData
 QDebug operator<<(QDebug d, const QWindowsTabletDeviceData &t);
 #endif
 
-class QWindowsTabletSupport
+class QWindowsTabletSupport : public QObject
 {
     Q_DISABLE_COPY(QWindowsTabletSupport)
 
@@ -141,6 +144,10 @@ public:
     int absoluteRange() const { return m_absoluteRange; }
     void setAbsoluteRange(int a) { m_absoluteRange = a; }
 
+private Q_SLOTS:
+    void slotPrimaryScreenChanged(QScreen *screen);
+    void slotScreenGeometryChanged();
+
 private:
     unsigned options() const;
     QWindowsTabletDeviceData tabletInit(qint64 uniqueId, UINT cursorType) const;
@@ -154,6 +161,8 @@ private:
     int m_currentDevice = -1;
     Mode m_mode = PenMode;
     State m_state = PenUp;
+    QScreen *m_connectedScreen = 0;
+    QRect m_mappedScreenGeometry;
 };
 
 QT_END_NAMESPACE
-- 
2.20.1.windows.1

